// Save binary output from Struck ADCs to ROOT trees.
// The binary file information is fetched from its index file
// generated by idx.C
void b2r(const char* index_file = "index.csv")
{
	cout<<"Open "<<index_file<<endl;
	ifstream index(index_file);
	if (index.is_open()==false) { cout<<"Failed! Quit"<<endl; return; }

	string line, hash, tmp, bit, binary_file, ADC;
	index>>hash>>tmp>>tmp>>tmp>>binary_file;

	cout<<"Open "<<binary_file<<endl;
	ifstream input(binary_file, ios::binary);
	if (index.is_open()==false) { cout<<"Failed! Quit"<<endl; return; }

	cout<<"Get type of ADC: ";
	int adc, nslot=21, nch=16; float sampling_rate=250;
	index>>hash>>tmp>>tmp>>tmp>>tmp>>ADC;
	adc=stoi(ADC.substr(2,4)); cout<<adc<<endl;
	if (adc==3316) { nch=16; sampling_rate=250; }

	cout<<"Get number of slots used: ";
	index>>hash>>tmp>>tmp>>tmp>>tmp>>nslot;
	cout<<nslot<<endl;

	// skip a few lines
	getline(index,line); getline(index,line); getline(index,line);
	getline(index,line); getline(index,line); getline(index,line);

	cout<<"Get channel status (0: empty):"<<endl;
	bool empty[21][16] = {0}; // whether a channel is empty
	index>>hash;
	for (int slot=0; slot<nslot; slot++) {
		for (int ch=0; ch<nch; ch++) {
			index>>empty[slot][ch];
			cout<<!empty[slot][ch]<<" ";
		}
		cout<<endl;
	}

	cout<<"Get channel format bits:"<<endl;
	bitset<4> format[21][16];
	getline(index,line); getline(index,line); index>>hash;
	for (int slot=0; slot<nslot; slot++) {
		for (int ch=0; ch<nch; ch++) {
			index>>bit; istringstream bit_stream(bit);
			bit_stream>>format[slot][ch];
			cout<<format[slot][ch]<<" ";
		}
		cout<<endl;
	}

	// skip a few lines
	getline(index,line); getline(index,line); getline(index,line);
	getline(index,line); getline(index,line); getline(index,line);

	cout<<"Get spill positions and sizes: ";
	int nspill=0; // total number of spills in file
	int spill[999] = {0}; // position of each spill in file (max 999 spills)
	int ssize[999] = {0}; // minimal size of a spill in all channels in a slot
	while (getline(index, line)) {
		nspill=stoi(line.substr(0,7));
		spill[nspill]=stoi(line.substr(9,19));
		ssize[nspill]=stoi(line.substr(21,28));
	}
	nspill++; cout<<nspill<<" spills to be read"<<endl;

	// generate root file name
	TString root_file(gSystem->BaseName(index_file));
	root_file.ReplaceAll("csv","root");

	cout<<"\nCreate "<<root_file<<endl;
	TFile *output = new TFile(root_file, "recreate");
	int	sum[8]={0}; // accumulator sums
	int	ih, max, vbt, vat; float es, em, h;
	int n, ns; long long ts; float s[99999]={0}, t[99999]; 
	for (int i=0; i<99999; i++) t[i]=i*(1000/sampling_rate);

	cout<<"Create a tree per channel"<<endl;
	TTree* tree[21][16]={0};
	for (int slot=0; slot<nslot; slot++) {
		for (int ch=0; ch<nch; ch++) {
			if (empty[slot][ch]) continue; // don't create tree for empty channel
			tree[slot][ch] = new TTree(Form("t%d",slot*nch+ch),
					Form("SIS3316 channel %d",slot*nch+ch));
			tree[slot][ch]->Branch("n", &n, "n/I"); // number of waveform samples
			tree[slot][ch]->Branch("s", s, "s[n]/F"); // waveform samples
			tree[slot][ch]->Branch("t", t, "t[n]/F"); // time [ns] of waveform samples
			tree[slot][ch]->Branch("ts", &ts, "ts/l"); // 48-bit event timestamp
			if (format[slot][ch][0]==1) {
				tree[slot][ch]->Branch("ns", &ns, "ns/I"); // number of accumulator sums
				tree[slot][ch]->Branch("sum", sum, "sum[ns]/I"); // accumulator sums
				tree[slot][ch]->Branch("h", &h, "h/F"); // height of a waveform
				tree[slot][ch]->Branch("ih", &ih, "ih/I"); // sample index of the highest point
			}
			if (format[slot][ch][2]==1) {
				tree[slot][ch]->Branch("max", &max, "max/I"); // MAW maximum value
				tree[slot][ch]->Branch("vbt", &vbt, "vbt/I"); // MAW value before trigger
				tree[slot][ch]->Branch("vat", &vat, "vat/I"); // MAW value after trigger
			}
			if (format[slot][ch][3]==1) {
				tree[slot][ch]->Branch("es", &es, "es/F"); // start energy value
				tree[slot][ch]->Branch("em", &em, "em/F"); // max energy value
			}
		}
	}

	cout<<"\nConvert binary input to ROOT trees..."<<endl;
	int word[100]; // read not more than 100 words at a time
	char* byte = (char*) word; // index in unit of byte instead of word
	for (int ispill=0; ispill<nspill; ispill++) { // loop over spills
		input.seekg(spill[ispill], ios::beg); // jump to the start of a spill

		for (int slot=0; slot<nslot; slot++) { // loop over slot
			input.seekg(8, ios::cur); // skip slot header (8 bytes)

			for (int ch=0; ch<nch; ch++) { // loop over channels
				input.read(byte,32); // get channel header (8 words)
				int nwords=word[7]; // size of a spill of data for a channel (words)
				int dw = nwords-ssize[ispill];
				if (slot==0) nwords=ssize[ispill];

				while (nwords>0) { // loop over events
					input.read(byte,8); nwords-=2; // get event header
					ts = *word&0xffff0000; // upper timestamp (started at 16th bit)
					ts = ts<<16; // move it up by 16 bit again
					ts = ts + word[1]; // combine upper (16) and lower (32) bits

					if (format[slot][ch][0]==1) { // peak + accumulator sums (gate 1~6)
						input.read(byte,28); nwords-=7;
						h = float(*word&0xffff); ih = int((*word&0xffff0000)>>16);
						ns=6; sum[0]=word[1]&0xffffff;
						for (int i=1; i<6; i++) sum[i]=word[i+1];
					}
					if (format[slot][ch][1]==1) { // accumulator sums from gate 7 & 8
						input.read(byte,8); nwords-=2;
						ns=8; sum[6]=word[0]; sum[7]=word[1];
					}
					if (format[slot][ch][2]==1) { // moving average window (MAW) info.
						input.read(byte,12); nwords-=3;
						max=word[0]; vbt=word[1]; vat=word[2];
					}
					if (format[slot][ch][3]==1) { // energy values
						input.read(byte,8); nwords-=2;
						es=word[0]; em=word[1];
					}

					input.read(byte,4); nwords-=1; // number of waveform samples
					n=2*((*word)&0x3ffffff); bitset<4> flag(byte[3]);
					for (int i=0; i<n; i+=2) {
						input.read(byte,4); nwords-=1; // read two samples
						s[i]=*word&0xffff; s[i+1]=(*word&0xffff0000)>>16;
					}

					if (!empty[slot][ch]) tree[slot][ch]->Fill();
				}
				if (slot==0 && dw>0) input.seekg(dw*4,ios::cur);
			}
		}
		cout<<ispill+1<<"/"<<nspill<<" spills processed"<<endl;
	}
	input.close();

	cout<<"\nWrite trees to "<<output->GetName()<<endl;
	for (int slot=0; slot<nslot; slot++) {
		for (int ch=0; ch<nch; ch++) {
			if (empty[slot][ch]) continue;
			tree[slot][ch]->Write("", TObject::kOverwrite);
			printf("# of events in channel %2d: %8llu\n",
					slot*nch+ch, tree[slot][ch]->GetEntries());
		}
	}
	output->Close();
}

